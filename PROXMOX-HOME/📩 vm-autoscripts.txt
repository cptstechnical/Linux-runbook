#  Este servidor se utiliza como ejecutor de diferentes scripts a bajo nivel...

#=========================================================================================================================
#=========================================================================================================================
[ AUTOSCRIPT]::
# en este contenedor corren varios servicios de las instalaciones de abajo:
systemctl status monitor
systemctl status monitor

#=========================================================================================================================
#=========================================================================================================================
[ PROYECTO MONITOR]::

# script
cd /aptelliot
vim monitor.sh
--------------------------------------------------------------------------
#!/bin/bash

# Configuraci贸n: IP -> Nombre del dispositivo
declare -A IP_MAP
IP_MAP=( 
    ["192.168.1.1"]="Router"
    ["8.8.8.8"]="Google-DNS1"
    ["8.8.4.4"]="Google-DNS2"
    # Agrega tus 20 IPs con nombre
)

# Archivos
STATUS_FILE="/var/lib/aptelliot/ip_status.txt"
LOG_FILE="/var/log/monitor.log"
FROM_EMAIL="tuemail@gmail.com"
TO_EMAIL="destino@gmail.com"
SUBJECT="Cambio de estado de IP"
SMTP_CONFIG="/etc/msmtprc"

# Inicializar archivos si no existen
mkdir -p /var/lib/aptelliot
touch "$STATUS_FILE"
touch "$LOG_FILE"

# Funci贸n para enviar correo
send_email() {
    local ip=$1
    local name=$2
    local state=$3
    {
        echo -e "Subject: $SUBJECT\n\nEl dispositivo '$name' (IP: $ip) cambi贸 a estado: $state"
    } | msmtp --file="$SMTP_CONFIG" --from="$FROM_EMAIL" "$TO_EMAIL"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Enviado correo: $name ($ip) -> $state" >> "$LOG_FILE"
}

# Comprobar cada IP
for ip in "${!IP_MAP[@]}"; do
    ping -c 1 -W 1 "$ip" > /dev/null 2>&1
    current_status=$([ $? -eq 0 ] && echo "UP" || echo "DOWN")
    previous_status=$(grep "^$ip " "$STATUS_FILE" | awk '{print $2}')

    # Log del ping
    echo "$(date '+%Y-%m-%d %H:%M:%S') - Ping $ip (${IP_MAP[$ip]}): $current_status" >> "$LOG_FILE"

    # Si cambi贸 el estado, enviar correo y log
    if [ "$previous_status" != "$current_status" ]; then
        send_email "$ip" "${IP_MAP[$ip]}" "$current_status"
        # Actualizar o agregar estado
        grep -v "^$ip " "$STATUS_FILE" > "$STATUS_FILE.tmp"
        echo "$ip $current_status" >> "$STATUS_FILE.tmp"
        mv "$STATUS_FILE.tmp" "$STATUS_FILE"
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Estado actualizado: $ip -> $current_status" >> "$LOG_FILE"
    fi
done
--------------------------------------------------------------------------

chmod +x monitor.sh

# configuro la terminal en bash
apk add bash

# instalo msmtp, es ligero, minimalista y solo env铆a correo saliente (sirve para enviar mensajes puntuales no es un servidor de correo como postfix)
apk add msmtp

# compruebo permisos
#chmod 600 /etc/msmtprc

# configuro msmtprc con Gmail
vim /etc/msmtprc
---------------------------------------------
defaults
auth           on
tls            on
tls_trust_file /etc/ssl/certs/ca-certificates.crt
logfile        ~/.msmtp.log

account        gmail
host           smtp.gmail.com
port           587
from           tuemail@gmail.com
user           tuemail@gmail.com
password       TU_PASSWORD_APP
account default : gmail  
---------------------------------------------

# creo un servicio
vim /etc/systemd/system/monitor.service
---------------------------------------------
[Unit]
Description=Monitor de IPs y env铆o de alertas por correo
After=network.target

[Service]
Type=simple
ExecStart=/aptelliot/monitor.sh
Restart=always
RestartSec=60    # Ejecuta el script cada 60 segundos
User=root        # O usuario con permisos para msmtp
Environment=MSMTP_CONFIG=/etc/msmtprc

[Install]
WantedBy=multi-user.target
---------------------------------------------

# activo el servicio
systemctl daemon-reload
systemctl enable monitor.service
systemctl start monitor.service


#=========================================================================================================================
[ INSTALAR ANTIVIRUS]::
# paquetes de Linux de utilizaci贸n r谩pida y pr谩ctica (escaneres):
#  realizo la instalaci贸n de un antivirus para automatizar el escaner de archivos corruptos en el servidor

# instalaci贸n antivirus Linux:
##  clamav::
apt install clamav
apt install clamav-freshclam
# busco actualizaciones en la base de datos
sudo freshclam
# escaneo manualmente el sistema
# clamscan -[par谩metros] [ruta de carpeta]
# sudo clamscan -r /
sudo clamscan -r /home

#  formas de uso con clamav:
# guardo un registro de archivos infectados
sudo clamscan -l /ruta/al/archivo.txt -r /ruta/al/directorio

# mandar archivo a cuarentena (para no causar da帽o al servidor):
# sudo clamscan --move=/path/to/quarantine -r /ruta/al/directorio
sudo clamscan --move=/path/to/quarantine -r /ruta/al/directorio -l /ruta/al/archivo.txt

# borrar archivos maliciosos:
# sudo clamscan --remove -r /ruta/al/directorio
sudo clamscan --remove -r /ruta/al/directorio -l /ruta/al/archivo.txt

# actualizar base de datos 
sudo freshclam

# lo que puedo hacer es un cron y un alias para que automatice el an谩lisis de virus. 
# 


#=========================================================================================================================
#=========================================================================================================================
[ PROYECTO MENSAJERO PROGRAMADO]::
# Documentaci贸n oficial kismet :             https://www.kismetwireless.net/docs/readme/installing/linux/
# documentaci贸n oficial clamav :             https://docs.clamav.net/

# -
[ MENSAJES PROGRAMADOS]::
#  enviar谩 cad d铆a un mensaje programado a la misma hora (siempre que lo haya), ordenando los archivos a enviar por orden.
#  una vez enviado, se clasifica el mensaje dentro de la carpeta /enviados de la misma ruta y aunque permanezca en el servidor no se volver谩 a mandar dicho mensaje.
#  al mover el mensaje a la carpeta enviados le cambia el nombre por la fecha y luego su nombree original para que no sobreescriban. Ej: 20250619_082815_nombre.txt

# creo una carpeta con los mensajes
mkdir /aptelliot/mensajes

# instalo postfix
apt install postfix
    - web

# entro en carpeta de scripts
cd /aptelliot

#  creo el script en el caso que el correo remitente sea de dominio
vim enviar-mensaje.sh
--------------------------------------------------------------------------
#!/bin/bash

CARPETA="/aptelliot/mensajes"
DESTINO="to@dominio.es"               # DESTINO="primero@dominio.com, segundo@dominio.com, tercero@dominio.com"
DESTINO_OCULTO="bcc@dominio.com"      # DESTINO_OCULTO="primero@dominio.com, segundo@dominio.com, tercero@dominio.com"
ASUNTO="Nuevo mensaje"
REMITENTE="from@dominio.es"           # correo real
DESTINO_ENVIADOS="$CARPETA/enviados"

# Crear carpeta de enviados si no existe
mkdir -p "$DESTINO_ENVIADOS"

# Buscar el primer archivo por orden
archivo=$(ls "$CARPETA"/*.txt 2>/dev/null | sort | head -n 1)

if [ -n "$archivo" ]; then
    echo "Enviando: $archivo a $DESTINO (BCC: $DESTINO_OCULTO)"

    (
        echo "Subject: $ASUNTO"
        echo "From: $REMITENTE"
        echo "To: $DESTINO"
        echo "Bcc: $DESTINO_OCULTO"
        echo "Content-Type: text/plain; charset=utf-8"
        echo
        cat "$archivo"
    ) | sendmail -f "$REMITENTE" -t

    if [ $? -eq 0 ]; then
        echo "Correo enviado exitosamente."
        nombre=$(basename "$archivo")
        timestamp=$(date +%Y%m%d_%H%M%S)
        mv "$archivo" "$DESTINO_ENVIADOS/${timestamp}_$nombre"
    else
        echo "Error al enviar el correo."
    fi
else
    echo "No hay mensajes pendientes por enviar."
fi
--------------------------------------------------------------------------

crontab -e
--------------------------------------------------------------------------
# cada d铆a a las 4:00
0 4 * * * /aptelliot/enviar-mensaje.sh
--------------------------------------------------------------------------

